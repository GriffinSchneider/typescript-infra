#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import glob from 'glob';
import mkdirp from 'mkdirp';
import { getProjectApiPackages, LernaPackage } from '../lib';

function outputFolder(pack: LernaPackage) {
  return path.join(pack.location, 'src', 'generated');
}

function stringForRouteFile(file: string, i: number) {
  // Import and then declare a variable so that, if a routes file exports something that isn't a route handling function,
  // it's clear which file is exporting the bad thing.
  return `import { router as router${i} } from '${file}';\n`;
}

function routeBarrelContents(pack: LernaPackage, routeFilenames: string[]): string {
  // Get the relative paths from our barrel file to the files we're importing, without the file extensions.
  const relativeRouteFilenames = routeFilenames.map(r => {
    const relative = path.relative(outputFolder(pack), r);
    const parsed = path.parse(relative);
    return path.join(parsed.dir, parsed.name);
  });
  const imports = relativeRouteFilenames.map(stringForRouteFile).join('');
  const beginning = '// Generated by scripts/generate-route-barrels.\n\n';
  const exp = `\nexport const routers = [${relativeRouteFilenames.map((r, i) => `router${i}`).join(', ')}];\n`;
  return beginning + imports + exp;
}

const apiPackages = getProjectApiPackages();
apiPackages.forEach(pack => {
  const g = path.join(pack.location, 'src', 'routes', '**', '*.ts');
  glob(g, (err, matches) => {
    if (err) { throw err; }
    const contents = routeBarrelContents(pack, matches);
    const folder = outputFolder(pack);
    mkdirp.sync(folder);
    fs.writeFileSync(path.join(outputFolder(pack), 'routes.ts'), contents);
  });
});
